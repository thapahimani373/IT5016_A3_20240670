# leave_manager.py
"""Employee Leave Management System with Software Design Principles
    This program manages employee leave applications with clear application of software design principles.
"""

leave_counter = 500  # global counter for leave IDs (Planning stage, KISS)

class LeaveApplication:
    """Class stores all leave applications.
    Principles:
    - High Cohesion: All leave-related data and behavior are in one class.
    - Information Expert: The class has all the info needed for leave management."""
    all_applications = []  # KISS: simple storage list

    def __init__(self):
        global leave_counter
        leave_counter += 1
        self.app_id = leave_counter  # auto-generate leave ID (Requirement)
        self.emp_id = ""
        self.emp_name = ""
        self.leave_days = 0
        self.reason = ""
        self.status = "Pending"

        LeaveApplication.all_applications.append(self)  # KISS: simple append

    # --- Employee Details Input ---
    def input_employee_details(self):
        """SRP: Only collects employee details
        KISS: simple while loop for validation
        Encapsulation: stores employee info inside the object"""
        while True:
            self.emp_id = input("Enter Employee ID: ").strip()
            if self.emp_id != "":
                break
            else:
                print("Employee ID cannot be empty.")

        while True:
            self.emp_name = input("Enter Employee Name: ").strip()
            if self.emp_name != "":
                break
            else:
                print("Employee name cannot be empty.")

    # --- Leave Request Input ---
    def apply_leave(self):
        """SRP: Only collects leave information
        KISS: simple input validation loops
        """
        while True:
            try:
                self.leave_days = int(input("Enter number of leave days: "))
                if self.leave_days > 0:
                    break
                else:
                    print("Leave days must be positive.")
            except ValueError:
                print("Please enter a valid number.")

        while True:
            self.reason = input("Enter reason for leave: ").strip()
            if self.reason != "":
                break
            else:
                print("Reason cannot be empty.")

    # --- System Auto-Approval ---
    def system_check(self):
        """SRP: Only decides auto-approval
        KISS single if condition
        """
        if self.leave_days < 3:
            self.status = "Approved"
        else:
            self.status = "Pending"

    # --- Manager Review for Pending ---
    def manager_review(self):
        """SRP: Only processes manager decision
        KISS: simple y/n input
        Low Coupling main program does not manipulate object internals"""
        if self.status == "Pending":
            decision = input("Manager: Approve this leave? (y/n): ").lower()
            if decision == "y":
                self.status = "Approved"
            else:
                self.status = "Rejected"

    # --- Display Application Details ---
    def show_details(self, summary=False):
        """SRP: Prints application details
        Encapsulation: accesses object attributes via method
        Flexibility summary=True shows only key info, False shows full info"""
        
        print("\nLeave Application")
        
        details = {
            "Application ID": self.app_id,
            "Employee ID": self.emp_id,
            "Employee Name": self.emp_name,
            "Leave Days": self.leave_days,
            "Reason": self.reason,
            "Status": self.status
        }

        if summary:
            for key in ["Application ID", "Employee Name", "Status"]:
                print(f"{key}: {details[key]}")
        else:
            for key, value in details.items():
                print(f"{key}: {value}")


# --- Alternative Statistics Function ---
def display_statistics(applications):
    """SRP: Only calculates and displays statistics
    KISS: loop and dictionary to count statuses dynamically
    Flexibility new statuses can be added to dictionary easily"""
    
    stats = {
        "Approved": 0,
        "Pending": 0,
        "Rejected": 0
    }

    for app in applications:  # loop counts dynamically
        if app.status in stats:
            stats[app.status] += 1

    total = len(applications)

    print("\n=== Leave Applications Statistics ===")
    print(f"Total Applications   : {total}")
    for status, count in stats.items():
        print(f"{status} Applications : {count}")


# --- Main Program ---
if __name__ == "__main__":
    """Separation of Concerns: main loop manages program flow only
    Low Coupling does not manipulate object internals directly"""
    print("=== Employee Leave Management System ===")

    while True:
        app = LeaveApplication()       # Information Expert: class handles its own data
        app.input_employee_details()   # SRP, Encapsulation
        app.apply_leave()              # SRP, Encapsulation
        app.system_check()             # SRP, KISS
        app.manager_review()           # SRP, Low Coupling

        again = input("\nDo you want to enter another leave application? (y/n): ").lower()
        if again != "y":
            break

    print("\n=== All Applications ===")
    for a in LeaveApplication.all_applications:
        a.show_details()  # SRP, Encapsulation

    # --- Call Alternative Statistics Function ---
    display_statistics(LeaveApplication.all_applications)
